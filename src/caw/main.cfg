{
  base_dir: "~/src/caw/examples",
  proc_dict: "~/src/caw/src/libcw/flow/proc_dict.cfg",
  subnet_dict: "~/src/caw/src/libcw/flow/subnet_dict.cfg",
    
  programs: {

    rt_sine_00: {
      network: {
      
        procs: {
	  osc: { class:sine_tone, args:{ hz:100.0 }},
	  aout:{ class:audio_out, in:{ in:osc.out }, args:{ dev_label:"main"} }
	}
      }
    }

    // Demonstrate a simple two processor network.
    sine_file_01: {

      non_real_time_fl:true,
      durLimitSecs:5.0,

      network: {

        procs: {
          osc: { class: sine_tone },
          af:  { class: audio_file_out, in: { in:osc.out } args:{  fname:"$/out.wav"} }
        } 
      }          
    }


    // Demonstrate simple signal processing and how to apply a processor class prefix.
    mod_sine_02: {

      non_real_time_fl:true,
      durLimitSecs:5.0,

      network: {

        procs: {
          lfo:   { class: sine_tone, args:{ hz:3, dc:440, gain:110 }}
          sh:    { class: sample_hold,            in:{ in:lfo.out } }
          osc:   { class: sine_tone, preset:mono, in:{ hz:sh.out } },         
          af:    { class: audio_file_out,         in: { in:osc.out } args:{  fname:"$/out.wav"} }
        }
      }
    }


    // Demonstrate applying a preset at initialization time.
    presets_03: {

      non_real_time_fl:true,
      durLimitSecs:5.0,
      preset: "a",

      network: {

        procs: {
          lfo:   { class: sine_tone, args:{ hz:3, dc:440, gain:110 }}
          sh:    { class: sample_hold,    in:{ in:lfo.out } }
          osc:   { class: sine_tone,      in:{ hz:sh.out } },         
          af:    { class: audio_file_out, in: { in:osc.out } args:{  fname:"$/out.wav"} }
        }

        presets:
        {
	  a: { lfo: { hz:1.0, dc:880 }, osc: { gain:0.95 } },
	  b: { lfo: { hz:2.0, dc:220 }, osc: { gain:0.75 } },
	  c: { lfo: a880 },
	  d: [ a,b,0.5 ]
          
        }
      }
    }

    // Demonstrate the `print` processor and event programming.
    program_04: {
    
      non_real_time_fl:true,
        durLimitSecs: 10.0,
	
	network {
	  procs: {
	      tmr:   { class: timer,                               args:{ period_ms:1000.0 }},
	      cnt:   { class: counter,  in: { trigger:tmr.out },   args:{ min:0, max:3, inc:1, init:0, mode:modulo } },
	      print: { class: print,    in: { in:cnt.out, eol_fl:cnt.out }, args:{ text:["my","count"] }}
	  }
	}
      }

    // Demonstrate 'mult' inputs.
    mult_inputs_05: {
    
        non_real_time_fl:true,
        durLimitSecs: 10.0,
	
	network: {
	  procs: {
	      tmr:   { class: timer,                               args:{ period_ms:1000.0 }},
	      cnt:   { class: counter,  in: { trigger:tmr.out },   args:{ min:0, max:3, inc:1, init:0, mode:modulo } },
              numb:  { class: number,                              args:{ value:3 }},
              sum:   { class: add,      in: { in0:cnt.out, in1:numb.value } },
	      print: { class: print,    in: { in0:cnt.out, in1:sum.out, eol_fl:sum.out }, args:{ text:["cnt","add","count"] }}
	  }
	}
      }

      
   // Demonstrate different forms of the in-stmt
   mult_conn_06: {
     non_real_time_fl:true,
     durLimitSecs: 5.0,

     network: {
       procs: {
         osc:    { class: sine_tone, args: { chCnt:6, hz:[110,220,440,880,1760, 3520] }},
         split:  { class: audio_split, in:{ in:osc.out }, args: { select:[ 0,0, 1,1, 2,2 ] } },
         
         // Create merge.in0,in1,in2 by iterating across all outputs of 'split'.
         merge_a: { class: audio_merge, in:{ in_:split.out_ } },
         af_a:    { class: audio_file_out, in:{ in:merge_a.out },  args:{ fname:"$/out_a.wav" }}
      
        // Create merge.in0,in1 and connect them to split.out0 and split.out1
        merge_b:  { class: audio_merge, in:{ in_:split.out0_2 } },
        af_b:     { class: audio_file_out, in:{ in:merge_b.out },  args:{ fname:"$/out_b.wav" }}
      
        // Create merge.in0,in1 and connect them both to split.out1
        merge_c:  { class: audio_merge, in:{ in0_2:split.out1 } },
        af_c:     { class: audio_file_out, in:{ in:merge_c.out },  args:{ fname:"$/out_c.wav" }}
         
       }
     } 
   }


      // Demonstrate creating processors with explicit sfx-ids and connecting to them with a single in-stmt.
      proc_suffix_07: {
        non_real_time_fl:true,
        durLimitSecs: 5.0,

        network: {
          procs: {
            osc:    { class: sine_tone, args: { chCnt:6, hz:[110,220,440,880,1760, 3520] }},
            split:  { class: audio_split, in:{ in:osc.out }, args: { select:[ 0,0, 1,1, 2,2 ] } },

	    // Create 3 audio gain controls with explicit sfx-ids
            g0: { class:audio_gain, in:{ in:split0.out0 }, args:{ gain:0.9} },
            g1: { class:audio_gain, in:{ in:split0.out1 }, args:{ gain:0.5} },
            g2: { class:audio_gain, in:{ in:split0.out2 }, args:{ gain:0.1} },

	    // Create audio-merge inputs and connect them to 3 consecutive gain controls
	    // by iterating the in-stmt over the source proc sfx-id.
            merge: { class: audio_merge, in:{ in_:g_.out } },
            af:    { class: audio_file_out, in:{ in:merge.out },  args:{ fname:"$/out_a.wav" }}


         }
       } 
     }

   // Demonstrate instantiating 'mult' variables from the an 'args' statement.
    mix_08: {

      non_real_time_fl:true,
      durLimitSecs:5.0,
      
      network: {

        procs: {
          osc_a:  { class: sine_tone, args: { hz:110 } },
	  osc_b:  { class: sine_tone, args: { hz:220 } },
	  gain:   { class: number,    args: { value:0.5f } },

	  // Instantiate gain:0 and gain:1 to control the input gain of in:0 and in:1.
	  mix:   { class: audio_mix, in: { in0:osc_a.out, in1:osc_b.out }, args:{ igain0:[0.8, 0], igain1:[0, 0.2] } },
          af:    { class: audio_file_out, in: { in:mix.out } args:{  fname:"$/out.wav"} }
        } 
      }          
    }


   // Demonstrate a network with a polyphonic subnet.
   simple_poly_09: {
   
    non_real_time_fl:true,
     durLimitSecs: 5.0,

     network: {

        procs: {

          g_list:  { class: list, args: { in:0, list:[ 110f,220f,440f ]}},
	  dc_list: { class: list, args: { in:0, list:[ 220f,440f,880f ]}},
	  
          osc_poly: {
	    class: poly,
	    args: { count:3 },  // Create 3 instances of 'network'.
	   
	    network: {
	      procs: {
	        lfo:  { class: sine_tone,   in:{ _.dc:_.dc_list.value_, _.gain:_.g_list.value_ }  args: { chCnt:1, hz:3 }},
	        sh:   { class: sample_hold, in:{ in:lfo.out }},
	        osc:  { class: sine_tone,   in:{ hz: sh.out }},
	      }
	    }       	    
	  }

          // Iterate over the instances of `osc_poly.osc_.out` to create one `audio_merge`
	  // input for every output from the polyphonic network.
	  merge: { class: audio_merge,    in:{ in_:osc_poly.osc_.out}, args:{ gain:1, out_gain:0.5 }},
	  af:    { class: audio_file_out, in:{ in:merge.out }          args:{ fname:"$/out.wav"} }
        }
      }
    }


    feedback_10: {
          non_real_time_fl:true,
          maxCycleCount:    10,

          network: {
            procs: {
	      a:   { class: number,  log:{value:0}, args:{ value:1 }},
	      b:   { class: number,  log:{value:0}, args:{ value:2 }},
	      
	      add: { class: add,  in: { in0:a.value, in1:b.value }, out: { out:b.store }, 
	                          log:{out:0},   args:{ otype:int }}
	    }
	  }
	},

    feedback_11: {
          non_real_time_fl:true,
          maxCycleCount:    10,

          network: {
            procs: {
	      a:   { class: number,  log:{value:0}, args:{ value:1 }},
	      b:   { class: reg,     in:{ in:a.value }, log:{out:0} },
	      
	      add: { class: add,  in: { in0:a.value, in1:b.out }, out: { out:b.store }, 
	                          log:{out:0},   args:{ otype:int }}
	    }
	  }
	},


    

    

  }
}