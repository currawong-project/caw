{
  base_dir:    "/home/kevin/src/caw/src/caw/test/io",
  io_dict:     "/home/kevin/src/caw/src/caw/cfg/io.cfg"            // Runtime configuration file.
  proc_dict:   "/home/kevin/src/caw/src/libcw/flow/proc_dict.cfg", // Processor class definition file.
  udp_dict:    "/home/kevin/src/caw/src/libcw/flow/udp_dict.cfg",  // User defined proc files
  tracer: {  trace_cnt:1024, msg_cnt: 1024000, enable_fl:false, activate_fl:false, out_fname:"tracer" }
  log: { flags:[ date_time, file_out, console, overwrite_file ], level:info, log_filename:"~/temp/caw_log.txt", queue_blk_cnt:16, queue_blk_byte_cnt:4096 }

  programs: {

    log_test_integral: {
    
        non_real_time_fl:true,
        dur_limit_secs: 10.0,
	
	network: {
	  procs: {
	      tmr:   { class: timer,                               args:{ period_ms:1000.0 }, log: { verbosity:minimal, flags:[init] varL:[ out ] }},
	      cnt:   { class: counter,  in: { trigger:tmr.out },   args:{ min:0, max:3, inc:1, init:0, mode:modulo } log:{ flags:[all] varL:[ out0] }},
              numb:  { class: number,                              args:{ in:3 } log:{ flags:[all] } },
              sum:   { class: add,      in: { in0:cnt.out, in1:numb.out } },
	      print: { class: print,    in: { in0:cnt.out, in1:sum.out }, args:{ text:["cnt:","add:","eol"] }}
	  }
	}
      } // log_test_integral

    log_test_audio: {
    
        non_real_time_fl:true,
        dur_limit_secs: 0.05,
        network: {
      
          procs: {
	    osc: { class:sine_tone, args:{ hz:100.0 } log:{ verbosity:summary, flags:[init] varL:[ out ] } },
	  }
        }
      }  // log_test_audio

    log_test_string: {
      non_real_time_fl:true,
      dur_limit_secs: 10,
      
      network: {
	  procs: {
	      tmr:   { class: timer,                                  args:{ period_ms:1000.0 }, log: { verbosity:minimal, flags:[init] varL:[ out ] }},
	      cnt:   { class: counter,     in: { trigger:tmr.out },   args:{ min:0, max:4, inc:1, init:0, mode:modulo, out_type:uint } log:{ varL:[ out0] }},
	      slist: { class: string_list, in: { in:cnt.out },        args:{ list:["a","bb","ccc","dddd"] } log:{ varL[ out ]} }
	      print: { class: print,       in: { in0:cnt.out, in1:slist.out }, args:{ text:["cnt:"] } }
	  }
	}      
      } // log_test_string
    
    
    log_test_fbuf: {
    
        non_real_time_fl:true,
        dur_limit_secs: 10.0,
	sample_rate:16,
	frames_per_cycle:8
	
	
        network: {
      
          procs: {
	    osc: { class:sine_tone, args:{ hz:2.0 }  },
	    pv:  { class:pv_analysis, in:{ in:osc.out }, args:{ maxWndSmpN:16, wndSmpN:16, hopSmpN:8 }, log:{ verbosity:all, flags:[init] varL:[ out ] } },
	    
	  }
        }
      } // log_test_fbuf

    log_test_recd_list: {
    
        non_real_time_fl:true,
        dur_limit_secs: 10.0,
	
	
        network: {
      
          procs: {
	    tmr:   { class: timer,                                  args:{ period_ms:1000.0 }, log: { verbosity:minimal, flags:[init] varL:[ out ] }},
	    cnt:   { class: counter,     in: { trigger:tmr.out },   args:{ min:0, max:3, inc:1, init:0, mode:modulo, out_type:uint } log:{ verbosity:summary, varL:[ out0] }},
	    rlst:  { class: recd_list,   in: { index:cnt.out },     
	      args: {
	        cnt: 1,
		fname: "$/my_cfg.cfg",
		
		// if 'fname' is empty then use the following literal 'cfg'.
		cfg: { fmt: { fields:{ name  : { type:string,           doc:"my value name"},
		                       value : { type:uint,   value:-1, doc:"my value" }
		                     } },
		              data: [ { name:"foo", value:1 },
			              { name:"blah", value:2 },
				      { name:"zipf", value:3 },
				      { name:"stiv", value:4 },
			           ]
		       }
	      },
	      
	      log: { verbosity:all, varL:[ out ] }, 	    
	  },
	  p: { class: print, in: { in0:rlst.out } args:{ text:["r:",""], verbosity:all }, log: { verbosity:minimal varL:[ in0  ] } }
        }
      }
    }  // log_test_recd_list

    test_recd_route: {
    
        non_real_time_fl:true,
        dur_limit_secs: 10.0,
	
	
        network: {
      
          procs: {
	    tmr:   { class: timer,                                  args:{ period_ms:1000.0 }, log: { verbosity:minimal, flags:[init] varL:[ out ] }},
	    cnt:   { class: counter,     in: { trigger:tmr.out },   args:{ min:0, max:4, inc:1, init:0, mode:modulo, out_type:uint } log:{ varL:[ out0] }},
	    rlst:  { class: recd_list,   in: { index:cnt.out },     
	      args: {
	        cnt: 1,		
		cfg: { fmt: { fields:{ name  : { type:string,           doc:"my value name"},
		                       value : { type:uint,   value:-1, doc:"my value" }
		                     } },
		              data: [ { name:"foo", value:0 },
			              { name:"blah", value:1 },
				      { name:"zipf", value:0 },
				      { name:"stiv", value:1 },
			           ]
		       }
	      },
	      
	      log: { verbosity:silent, varL:[ out ] }, 	    
	  }
	  rr:    { class: recd_route, in:{ in:rlst.out } args:{ out_cnt:2, sel_field:"value" } }
	  p_a:   { class: print       in:{ in0:rr.out0 }, args:{ text:[ "A:" ], verbosity:all }}
	  p_b:   { class: print       in:{ in0:rr.out1 }, args:{ text:[ "B:" ], verbosity:all }}
	  
        }
      }
    }  // test_recd_route

    // Test the recd splitter and merger.
    test_recd_split_then_merge: {
    
        non_real_time_fl:true,
        dur_limit_secs: 10.0,
	
        network: {
      
          procs: {
	    tmr:   { class: timer,                                  args:{ period_ms:1000.0 }, log: { verbosity:minimal, flags:[init] varL:[ out ] }},
	    cnt:   { class: counter,     in: { trigger:tmr.out },   args:{ min:0, max:4, inc:1, init:0, mode:modulo, out_type:uint } log:{ varL:[ out0] }},
	    rlst:  { class: recd_list,   in: { index:cnt.out },     
	      args: {
	        cnt: 1,		
		cfg: { fmt: { fields:{ name  : { type:string,           doc:"my value name"},
		                       value : { type:uint,   value:-1, doc:"my value" }
		                     } },
		              data: [ { name:"foo", value:0 },
			              { name:"blah", value:1 },
				      { name:"zipf", value:0 },
				      { name:"stiv", value:1 },
			           ]
		       }
	      },
	      
	      log: { verbosity:silent, varL:[ out ] }, 	    
	  }
	  rr:    { class: recd_route, in:{ in:rlst.out } args:{ out_cnt:2, sel_field:"value" } },
	  p_a    { class: print       in:{ in0:rr.out0, in1:rr.out1 }, args:{ verbosity:all} }
	  rm:    { class: recd_merge, in:{ in0:rr.out0, in1:rr.out1 } },
	  p_b:   { class: print       in:{ in0:rm.out }, args:{ verbosity:all} }
	  
	  },
	  
        }
    }  // test_recd_split_then_merge

    // This network demonstrates the use of 'recd_pass' to implement record feedback.
    test_recd_feedback: {
    
        non_real_time_fl:true,
        dur_limit_secs: 10.0,
	
        network: {

          procs: {
	    tmr:   { class: timer,                                  args:{ period_ms:1000.0 }, log: { verbosity:minimal, flags:[init] varL:[ out ] }},
	    cnt:   { class: counter,     in: { trigger:tmr.out },   args:{ min:0, max:4, inc:1, init:0, mode:modulo, out_type:uint } log:{ varL:[ out0] }},

	    rpass: { class: recd_pass,
	             args:{
		     
		        // Notice that the downstream procs from rpass may rely on the output record variale
			// maxRecdN to set their own internal recd_array size. So the alloc cnt here should be
			// generous.  If it turns out that  the true count of records being fed from the the
			// feedback connection is larger then their could be problems - albeit the problem
			// should merely give a warning and the size of alloc_cnt could be increased.
		        fmt: { alloc_cnt:1024, fields:{ name  : { type:string,           doc:"my value name"},
		                                        value : { type:uint,   value:-1, doc:"my value" } } } } },
				
	    p_a:    { class: print       in:{ in0:rpass.out }, args:{ text:["fb:",""], verbosity:all} }

	    rlst:  { class: recd_list,   in: { index:cnt.out },     
	      args: {
	        cnt: 1,		
		cfg: { fmt: { fields:{ name  : { type:string,           doc:"my value name"},
		                       value : { type:uint,   value:-1, doc:"my value" }
		                     } },
		              data: [ { name:"foo", value:0 },
			              { name:"blah", value:1 },
				      { name:"zipf", value:0 },
				      { name:"stiv", value:1 },
			           ]
		       }
	      },
	      
	      log: { verbosity:silent, varL:[ out ] },
	      out: { out:rpass.in }
	    }
	    
	    p_b:    { class: print       in:{ in0:rlst.out }, args:{ text:["out:",""], verbosity:all} }

	  },
	  
        }
    }  // test_recd_feedback


    // This network exercises the record registry
    // The record registry allows record formats to be stored separately,
    // either int `network: {records:{...}}` or in the proc description
    // registry - where they are attached to 'record' variables.
    // Notice that this network demonstrates refering to record formats
    // by name, and 'test_recd_feedback' which is functionaly identical
    // refers to record formats by specifying the format directly.
    // See proc_recd_format_create() and network_find_record_format().
    test_recd_registry: {
    
        non_real_time_fl:true,
        dur_limit_secs: 10.0,
	
        network: {
	  records: {
	    my_fmt: { fields:{ name  : { type:string,           doc:"my value name"},
		               value : { type:uint,   value:-1, doc:"my value" } } }
	  }

          procs: {
	    tmr:   { class: timer,                                  args:{ period_ms:1000.0 }, log: { verbosity:minimal, flags:[init] varL:[ out ] }},
	    cnt:   { class: counter,     in: { trigger:tmr.out },   args:{ min:0, max:4, inc:1, init:0, mode:modulo, out_type:uint } log:{ varL:[ out0] }},

	    rpass: { class: recd_pass,
	             args:{ fmt: { alloc_cnt:1024, fields:my_fmt } } },
				
	    p_a:    { class: print       in:{ in0:rpass.out }, args:{ text:["fb:",""], verbosity:all} }

	    rlst:  { class: recd_list,   in: { index:cnt.out },     
	      args: {
	        cnt: 1,		
		cfg: { fmt: my_fmt,
		       data: [ { name:"foo", value:0 },
			       { name:"blah", value:1 },
			       { name:"zipf", value:0 },
			       { name:"stiv", value:1 },
			     ]
		      }
	      },
	      
	      log: { verbosity:silent, varL:[ out ] },
	      out: { out:rpass.in }
	    }
	    
	    p_b:    { class: print       in:{ in0:rlst.out }, args:{ text:["out:",""], verbosity:all} }

	  },
	  
        }
    }  // test_recd_registry


    test_number: {

        non_real_time_fl:true,
        dur_limit_secs: 0.25,

	network:
	{
	  procs: {
	    n_a : { class: number, args:{ in:1 } }
	    n_b : { class: number, args:{ in:1 } }
	    add_a : { class: add, in: { in0:n_a.out, in1:n_b.out } },	    
	    p_a : { class: print, in:{ in0:add_a.out }, args:{ text:["A:"]} }
	    
	    n_c : { class: number, args:{ in:1 } }
	    add_b : { class: add, in: { in0:n_c.out, in1:add_a.out }, out:{ out:n_a.in } }
	    p_b : { class: print, in:{ in0::add_b.out } args:{ text:["B:"]} }

	    
	    
	  } 
	}

    }

  }
}